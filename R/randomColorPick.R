#' Constructing a ggplot-styled map of the Belgium, with colors for the different zones that are selected randomly
#'
#' @param plottingSpatialEffectCyclingOutputObject Output object of the 'plottingSpatialEffect' function (generated by toggling the 'randomPick' argument to TRUE). This is an obligatory argument, without default value.
#' @param predFactColors Character vector of length equal to the number of different values of the 'predictions' argument. Only if the 'predAsFact' argument is toggled to TRUE, this argument is taken into account. This is an optional argument, with NULL as default value.
#' @param printColourNames Logical vector of length 1 indicating whether or not one wants to print the name of the randomly selected color names. As such, one can learn the actual names of nice-looking colors. This is an optional argument, with FALSE as default value.
#' @param noSaving Logical vector of length 1 indicating whether or not one wants to save the produced ggplot object. The arguments 'plotTitle', 'plotDir', 'plotName' and 'pdf2', necessary to save the plot, are automatically supplied by the 'plottingSpatialEffectCyclingOutputObject' argument, such that any changes regarding these arguments need to be done by the 'plottingSpatialEffect' function. This is an optional argument, with FALSE as default value.
#' @return A ggplot object is constructed with a different color for each zone (the predictions need to be a factor), each color being randomly selected.
#' @examples
#' library(data.table)
#' dirShape <<- '/home/robin/shape/'
#' postalCode <- read.csv(paste(defaultdirectoryShapeFile, "postins.csv", sep = "\\"))[,c("CODPOSS","INS")]
#' inputDT <- data.table(postalCode = postalCode$CODPOSS, exposure = runif(nrow(postalCode)))
#' predictions <- as.numeric(as.character(postalCode$CODPOSS))
#' # If doesn't know which colour should be chosen, one can use the
#' # 'randomPick' argument and the 'randomColorPick' function.
#' inputCyclingFunction <- plottingSpatialEffect(inputDT, predictions, predAsFact = TRUE, randomPick = TRUE)
#' randomColorPick(inputCyclingFunction, , TRUE)
randomColorPick <- function(plottingSpatialEffectCyclingOutputObject, predFactColors = NULL, printColourNames = FALSE, noSaving = FALSE){
  
  checkLogicVec(list(printColourNames, noSaving))
  checkLength(list(printColourNames, noSaving), 1)
  
  belgiumFortified <- plottingSpatialEffectCyclingOutputObject$belgiumFortified
  plotTitle <- plottingSpatialEffectCyclingOutputObject$plotTitle
  plotDir <- plottingSpatialEffectCyclingOutputObject$plotDir
  plotName <- plottingSpatialEffectCyclingOutputObject$plotName
  pdf2 <- plottingSpatialEffectCyclingOutputObject$pdf2
  
  if(is.null(predFactColors)){
    
    colorPalette <- colors()[-grep('white', colors())]
    colorPalette <- colorPalette[-grep('grey', colorPalette)]
    colorPalette <- colorPalette[-grep('gray', colorPalette)]
    colorPalette <- colorPalette[-grep('ivory', colorPalette)]
    colorPalette <- colorPalette[-grep('silk', colorPalette)]
    colorPalette <- colorPalette[-grep('bisque', colorPalette)]
    colorPalette <- colorPalette[-grep('lightyellow', colorPalette)]
    colorPalette <- colorPalette[-grep('honeydew', colorPalette)]
    colorPalette <- colorPalette[-grep('palegolden', colorPalette)]
    colorPalette <- colorPalette[-grep('mint', colorPalette)]
    colorPalette <- colorPalette[-grep('lavender', colorPalette)]
    colorPalette <- colorPalette[-grep('lightcyan', colorPalette)]
    colorPalette <- colorPalette[-grep('lemon', colorPalette)]
    colorPalette <- colorPalette[-grep('linen', colorPalette)]
    colorPalette <- colorPalette[-grep('snow', colorPalette)]
    colorPalette <- colorPalette[-grep('almond', colorPalette)]
    colorPalette <- colorPalette[-grep('wheat', colorPalette)]
    colorPalette <- colorPalette[-grep('tan', colorPalette)]
    colorPalette <- colorPalette[-grep('azure', colorPalette)]
    colorPalette <- colorPalette[-grep('papaya', colorPalette)]
    colorPalette <- colorPalette[-grep('lightgolden', colorPalette)]
    
    predFactColors <- colorPalette[sample(1:length(colorPalette), length(unique(belgiumFortified$predicted)))]
    
  } else {
    checkLength(list(predFactColors), length(unique(inputDT$predicted)))
    if(sum(predFactColors %in% colors()) != length(unique(inputDT$predicted))) stop('Some of the values of the "predFactColors" argument are not valid color names. The valid values can be found by running the "colors()" function on the command line.')
  }
  
  mapPredictions <- ggplot(belgiumFortified, aes(long, lat, group = group, fill = factor(predicted), text = paste(paste(paste('Postal Code: ', postalCode, sep = ''), ' -- ', sep = ''), Name1, sep = ''))) + xlab('Longitude') + ylab('Latitude') + scale_fill_manual(name = "Predictions", values = predFactColors) + geom_polygon() + ggtitle(paste(plotTitle, ': Predictions', sep = ''))
  
  if(!noSaving){
    if(!is.null(plotDir) & !is.null(plotName)){
      if(pdf2) ggsave(paste(plotDir, paste(plotName, '.pdf', sep = ''), sep = ""))
      ggsave(paste(plotDir, paste(plotName, '.png', sep = ''), sep = ""))
    }
  }
  if(printColourNames == TRUE) print(predFactColors)
  return(mapPredictions)
  
}
